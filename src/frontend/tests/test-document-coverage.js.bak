#!/usr/bin/env node

const fetch = require('node-fetch')

class DocumentCoverageTester {
  constructor(baseUrl = 'http://localhost:3001') {
    this.baseUrl = baseUrl
    this.testResults = []
  }

  async testDocumentRetrieval(query, expectedMinSources = 3) {
    console.log(`\nðŸ” Testing document retrieval for: "${query}"`)
    const startTime = Date.now()
    
    try {
      const response = await fetch(`${this.baseUrl}/api/query`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query }),
        timeout: 30000
      })
      
      const responseTime = Date.now() - startTime
      
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`)
      }
      
      const data = await response.json()
      
      const result = {
        query,
        success: true,
        responseTime,
        chunksFound: data.chunks?.length || 0,
        sourcesFound: data.sources?.length || 0,
        expectedMinSources,
        meetsExpectation: (data.chunks?.length || 0) >= expectedMinSources,
        isErrorFallback: !!data.error_fallback,
        data
      }
      
      this.testResults.push(result)
      
      console.log(`   ðŸ“Š Chunks found: ${result.chunksFound}`)
      console.log(`   ðŸ“š Sources found: ${result.sourcesFound}`)
      console.log(`   ðŸŽ¯ Expected minimum: ${expectedMinSources}`)
      console.log(`   ${result.meetsExpectation ? 'âœ…' : 'âŒ'} Meets expectation: ${result.meetsExpectation}`)
      console.log(`   ${result.isErrorFallback ? 'ðŸš¨' : 'âœ…'} Using real database: ${!result.isErrorFallback}`)
      
      if (!result.meetsExpectation) {
        console.log(`   âš ï¸  WARNING: Only found ${result.chunksFound} chunks, expected at least ${expectedMinSources}`)
        if (result.isErrorFallback) {
          console.log(`   ðŸ” System fell back to error response - database connection issue`)
        } else {
          console.log(`   ðŸ” This suggests limited document retrieval`)
        }
      }
      
      // Check for document diversity
      const uniqueSources = new Set()
      if (data.chunks) {
        data.chunks.forEach(chunk => {
          if (chunk.metadata?.document_name) {
            uniqueSources.add(chunk.metadata.document_name)
          }
        })
      }
      
      result.uniqueDocuments = uniqueSources.size
      console.log(`   ðŸ“– Unique documents: ${result.uniqueDocuments}`)
      
      if (result.uniqueDocuments < 2 && result.chunksFound >= 2) {
        console.log(`   âš ï¸  WARNING: All chunks from same document - limited diversity`)
      }
      
      return result
      
    } catch (error) {
      const responseTime = Date.now() - startTime
      const result = {
        query,
        success: false,
        responseTime,
        error: error.message,
        chunksFound: 0,
        sourcesFound: 0,
        expectedMinSources,
        meetsExpectation: false,
        isErrorFallback: true
      }
      
      this.testResults.push(result)
      console.log(`   âŒ Error: ${error.message}`)
      return result
    }
  }

  async runDocumentCoverageTests() {
    console.log('ðŸ“š Testing Document Retrieval Coverage')
    console.log('=====================================')
    console.log(`Base URL: ${this.baseUrl}`)
    
    // Test various query types that should return different document sets
    const testQueries = [
      { query: "circular economy sustainability environment", minSources: 4, description: "Broad concept query" },
      { query: "circularity gap measurement", minSources: 3, description: "Specific metric query" },
      { query: "business model innovation", minSources: 3, description: "Business focus query" },
      { query: "waste management recycling", minSources: 4, description: "Technical process query" },
      { query: "Ellen MacArthur Foundation", minSources: 2, description: "Organization query" }
    ]
    
    console.log(`\nðŸ§ª Running ${testQueries.length} document coverage tests...`)
    
    for (const test of testQueries) {
      await this.testDocumentRetrieval(test.query, test.minSources)
    }
  }

  printSummary() {
    console.log('\n' + '='.repeat(60))
    console.log('ðŸ“š DOCUMENT COVERAGE TEST SUMMARY')
    console.log('='.repeat(60))
    
    const successful = this.testResults.filter(r => r.success && r.meetsExpectation && !r.isErrorFallback)
    const insufficient = this.testResults.filter(r => r.success && !r.meetsExpectation)
    const errorFallbacks = this.testResults.filter(r => r.isErrorFallback)
    const failed = this.testResults.filter(r => !r.success)
    
    console.log(`âœ… Adequate coverage: ${successful.length}`)
    console.log(`âš ï¸  Insufficient coverage: ${insufficient.length}`)
    console.log(`ðŸš¨ Error fallbacks: ${errorFallbacks.length}`)
    console.log(`âŒ Failed queries: ${failed.length}`)
    console.log(`ðŸ“Š Total queries: ${this.testResults.length}`)
    
    const workingTests = this.testResults.filter(r => r.success && !r.isErrorFallback)
    if (workingTests.length > 0) {
      const avgChunks = workingTests.reduce((sum, r) => sum + r.chunksFound, 0) / workingTests.length
      console.log(`ðŸ“ˆ Average chunks per query: ${avgChunks.toFixed(1)}`)
    }
    
    console.log(`\nðŸ” ROOT CAUSE ANALYSIS:`)
    
    if (errorFallbacks.length > 0) {
      console.log(`   ðŸš¨ CRITICAL: ${errorFallbacks.length} queries hit error fallbacks`)
      console.log(`   ðŸ“‹ LIKELY CAUSES:`)
      console.log(`      â€¢ Missing environment variables (GEMINI_API_KEY, SUPABASE_*)`)
      console.log(`      â€¢ Supabase database not accessible`)
      console.log(`      â€¢ API quota exceeded`)
      console.log(`      â€¢ Network connectivity issues`)
    }
    
    if (successful.length === 0 && errorFallbacks.length === 0) {
      console.log(`   âŒ PROBLEM: System may be using mock responses`)
      console.log(`   ðŸ”§ SOLUTION: Check if real RAG pipeline is connected`)
    } else if (successful.length > 0) {
      console.log(`   âœ… GOOD: System is successfully using real database`)
      console.log(`   ðŸ“‹ EVIDENCE: Varied chunk counts and document diversity`)
    }
    
    const coverageRate = (successful.length / this.testResults.length) * 100
    console.log(`\nðŸŽ¯ Document Coverage Rate: ${coverageRate.toFixed(1)}%`)
    
    if (coverageRate < 60) {
      console.log(`ðŸš¨ CRITICAL: Document coverage is below acceptable threshold (60%)`)
      console.log(`   This will significantly impact answer quality and comprehensiveness`)
      process.exit(1)
    } else if (coverageRate < 80) {
      console.log(`âš ï¸  WARNING: Document coverage is below optimal threshold (80%)`)
      console.log(`   Consider investigating and improving database connectivity`)
      process.exit(0)
    } else {
      console.log(`ðŸŽ‰ EXCELLENT: Document coverage meets quality standards`)
      process.exit(0)
    }
  }
}

async function main() {
  const tester = new DocumentCoverageTester()
  
  try {
    await tester.runDocumentCoverageTests()
    tester.printSummary()
  } catch (error) {
    console.error('ðŸ’¥ Document coverage test failed:', error.message)
    process.exit(1)
  }
}

main()
