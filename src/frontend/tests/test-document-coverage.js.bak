#!/usr/bin/env node

const fetch = require('node-fetch')

class DocumentCoverageTester {
  constructor(baseUrl = 'http://localhost:3001') {
    this.baseUrl = baseUrl
    this.testResults = []
  }

  async testDocumentRetrieval(query, expectedMinSources = 3) {
    console.log(`\n🔍 Testing document retrieval for: "${query}"`)
    const startTime = Date.now()
    
    try {
      const response = await fetch(`${this.baseUrl}/api/query`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ query }),
        timeout: 30000
      })
      
      const responseTime = Date.now() - startTime
      
      if (!response.ok) {
        throw new Error(`API error: ${response.status}`)
      }
      
      const data = await response.json()
      
      const result = {
        query,
        success: true,
        responseTime,
        chunksFound: data.chunks?.length || 0,
        sourcesFound: data.sources?.length || 0,
        expectedMinSources,
        meetsExpectation: (data.chunks?.length || 0) >= expectedMinSources,
        isErrorFallback: !!data.error_fallback,
        data
      }
      
      this.testResults.push(result)
      
      console.log(`   📊 Chunks found: ${result.chunksFound}`)
      console.log(`   📚 Sources found: ${result.sourcesFound}`)
      console.log(`   🎯 Expected minimum: ${expectedMinSources}`)
      console.log(`   ${result.meetsExpectation ? '✅' : '❌'} Meets expectation: ${result.meetsExpectation}`)
      console.log(`   ${result.isErrorFallback ? '🚨' : '✅'} Using real database: ${!result.isErrorFallback}`)
      
      if (!result.meetsExpectation) {
        console.log(`   ⚠️  WARNING: Only found ${result.chunksFound} chunks, expected at least ${expectedMinSources}`)
        if (result.isErrorFallback) {
          console.log(`   🔍 System fell back to error response - database connection issue`)
        } else {
          console.log(`   🔍 This suggests limited document retrieval`)
        }
      }
      
      // Check for document diversity
      const uniqueSources = new Set()
      if (data.chunks) {
        data.chunks.forEach(chunk => {
          if (chunk.metadata?.document_name) {
            uniqueSources.add(chunk.metadata.document_name)
          }
        })
      }
      
      result.uniqueDocuments = uniqueSources.size
      console.log(`   📖 Unique documents: ${result.uniqueDocuments}`)
      
      if (result.uniqueDocuments < 2 && result.chunksFound >= 2) {
        console.log(`   ⚠️  WARNING: All chunks from same document - limited diversity`)
      }
      
      return result
      
    } catch (error) {
      const responseTime = Date.now() - startTime
      const result = {
        query,
        success: false,
        responseTime,
        error: error.message,
        chunksFound: 0,
        sourcesFound: 0,
        expectedMinSources,
        meetsExpectation: false,
        isErrorFallback: true
      }
      
      this.testResults.push(result)
      console.log(`   ❌ Error: ${error.message}`)
      return result
    }
  }

  async runDocumentCoverageTests() {
    console.log('📚 Testing Document Retrieval Coverage')
    console.log('=====================================')
    console.log(`Base URL: ${this.baseUrl}`)
    
    // Test various query types that should return different document sets
    const testQueries = [
      { query: "circular economy sustainability environment", minSources: 4, description: "Broad concept query" },
      { query: "circularity gap measurement", minSources: 3, description: "Specific metric query" },
      { query: "business model innovation", minSources: 3, description: "Business focus query" },
      { query: "waste management recycling", minSources: 4, description: "Technical process query" },
      { query: "Ellen MacArthur Foundation", minSources: 2, description: "Organization query" }
    ]
    
    console.log(`\n🧪 Running ${testQueries.length} document coverage tests...`)
    
    for (const test of testQueries) {
      await this.testDocumentRetrieval(test.query, test.minSources)
    }
  }

  printSummary() {
    console.log('\n' + '='.repeat(60))
    console.log('📚 DOCUMENT COVERAGE TEST SUMMARY')
    console.log('='.repeat(60))
    
    const successful = this.testResults.filter(r => r.success && r.meetsExpectation && !r.isErrorFallback)
    const insufficient = this.testResults.filter(r => r.success && !r.meetsExpectation)
    const errorFallbacks = this.testResults.filter(r => r.isErrorFallback)
    const failed = this.testResults.filter(r => !r.success)
    
    console.log(`✅ Adequate coverage: ${successful.length}`)
    console.log(`⚠️  Insufficient coverage: ${insufficient.length}`)
    console.log(`🚨 Error fallbacks: ${errorFallbacks.length}`)
    console.log(`❌ Failed queries: ${failed.length}`)
    console.log(`📊 Total queries: ${this.testResults.length}`)
    
    const workingTests = this.testResults.filter(r => r.success && !r.isErrorFallback)
    if (workingTests.length > 0) {
      const avgChunks = workingTests.reduce((sum, r) => sum + r.chunksFound, 0) / workingTests.length
      console.log(`📈 Average chunks per query: ${avgChunks.toFixed(1)}`)
    }
    
    console.log(`\n🔍 ROOT CAUSE ANALYSIS:`)
    
    if (errorFallbacks.length > 0) {
      console.log(`   🚨 CRITICAL: ${errorFallbacks.length} queries hit error fallbacks`)
      console.log(`   📋 LIKELY CAUSES:`)
      console.log(`      • Missing environment variables (GEMINI_API_KEY, SUPABASE_*)`)
      console.log(`      • Supabase database not accessible`)
      console.log(`      • API quota exceeded`)
      console.log(`      • Network connectivity issues`)
    }
    
    if (successful.length === 0 && errorFallbacks.length === 0) {
      console.log(`   ❌ PROBLEM: System may be using mock responses`)
      console.log(`   🔧 SOLUTION: Check if real RAG pipeline is connected`)
    } else if (successful.length > 0) {
      console.log(`   ✅ GOOD: System is successfully using real database`)
      console.log(`   📋 EVIDENCE: Varied chunk counts and document diversity`)
    }
    
    const coverageRate = (successful.length / this.testResults.length) * 100
    console.log(`\n🎯 Document Coverage Rate: ${coverageRate.toFixed(1)}%`)
    
    if (coverageRate < 60) {
      console.log(`🚨 CRITICAL: Document coverage is below acceptable threshold (60%)`)
      console.log(`   This will significantly impact answer quality and comprehensiveness`)
      process.exit(1)
    } else if (coverageRate < 80) {
      console.log(`⚠️  WARNING: Document coverage is below optimal threshold (80%)`)
      console.log(`   Consider investigating and improving database connectivity`)
      process.exit(0)
    } else {
      console.log(`🎉 EXCELLENT: Document coverage meets quality standards`)
      process.exit(0)
    }
  }
}

async function main() {
  const tester = new DocumentCoverageTester()
  
  try {
    await tester.runDocumentCoverageTests()
    tester.printSummary()
  } catch (error) {
    console.error('💥 Document coverage test failed:', error.message)
    process.exit(1)
  }
}

main()
